// коллекции и тп

// List - список объектов

// пример списка:
List<int> ints = new List<int>(100); // создание и инициализация списка с элементами int
// <> - дженерики, обобщения. В угловых скобочках обозначается конкретный
// тип данных, который будет использоваться внутри класса
// = new List<int>(100); 100 - это начальная "вместимость" для внутреннего массива
// писать вместимость необязательно, но если мы собираемся сразу добавить
// в коллекцию большое число объектов, то желательно, чтобы предупредить
// лишние пересоздания внутреннего массива

// добавление данных
ints.Add(1); // добавление одного элемента
ints.AddRange(1, 2, 3, 4, 5); // добавление множества элементов
ints.AddRange(new int[] { 1, 2, 3, 4, 5 });// или так
//ints = new List<int>(new int[] { 1, 2, 3, 4, 5 }); // или так
ints.Remove(1); // удаление первого попавшегося объекта с значением 1
ints.RemoveAt(0); // удаление объекта по индексу 0
ints.RemoveRange(1, 2); // удаление двух ячеек, начиная с индекса 1

// c коллекцией можно работать как с массивом
ints[0] = 1;
Console.WriteLine(ints[0]);
foreach (int i in ints) 
    Console.WriteLine(i);

// используя лямбда-выражения, мы получаем доступ к многим 
// полезным методам
ints.RemoveAll(s => s > 5);

// лямбда-выражение - анонимный метод, который указывается в коде
// и передается сразу в делегат. Дальше этот метод используется 
// через делегат. Польза - не нужно плодить много маленьких
// методов, не нужно придумывать много имен, краткий синтаксис

// синтаксис лямбда: (аргументы) => тело или возращаемый результат
// если тело состоит из одной строки, которая является результатом,
// то можно опустить фигурные скобки и слово return

// (x,y) => x + y // лямбда, складывающая 2 числа
// s => s > 1 // лямбда, сравнивающая аргумент с 1

// тип аргументов и возвращаемого значения будет зависеть
// от принимающего делегата, поэтому в лямбде типы не указываются

// сортировка по умолчанию
ints.Sort();

// сортировка с использованием лямбды
// лямбда будет использована для сравнения объектов в коллекции
ints.Sort((x, y) => x.CompareTo(y)); // asc
ints.ForEach(x => Console.WriteLine(x)); // тоже лямбда 
ints.Sort((x, y) => y.CompareTo(x)); // desc
ints.ForEach(x => Console.WriteLine(x));

void Test() => Console.WriteLine("test"); // метод в стиле лямбда

//class TestClass
//{
//    private string title;

//    public string Title 
//    { // свойство в стиле лямбда (убрали {} и return)
//        get => title; 
//        set => title = value;
//    }
//}


// в фреймворке есть ряд стандартных делегатов (тоже с обобщением)
// которые удобно использовать и которые часто требуются в 
// стандартных классах
// Action - делегат, который описывает процедуру, может иметь ряд аргументов
// тип аргументов указывается через обобщение
// в делегат с двумя аргументами int передается лямбда
Action<int, int> action = (x, y) => Console.WriteLine(x + y);
action(1, 2); // вызов лямбды через делегат

// Func - делегат, который описывает функцию, последний тип в нем
// это тип возвращаемого значения
// в делегат с двумя аргументами int передается лямбда, возвращающая string
Func<int, int, string> func = (x, y) => (x + y).ToString();
string result = func(1, 2);

// найти первый ненулевой элемент
int resultFirst = ints.FirstOrDefault(s => s != 0);
// найти последний ненулевой элемент
var resultLast = ints.LastOrDefault(s => s != 0);

// выбрать все элементы и преобразовать каждый
List<string> strings = ints.Select(s => s.ToString()).ToList();
// Select возвращает тип IEnumerable<T>, это интерфейс перечислений
// для удобства работы его лучше преобразовать в массив или список

// пример
List<string> log = new List<string>();
string command = null;
while (command != "exit")
{ 
    Console.Write("Команда? ");
    command = Console.ReadLine();
    log.Add(command);
}

Console.WriteLine("Были использованы команды:");
log.ForEach(s => Console.WriteLine(s));
